#!/usr/bin/python
#
# The init script for object-drive-server. Save to /etc/init.d
#
#
# chkconfig: - 20 70
# description: object-drive-1.0 server process
#
#
### BEGIN INIT INFO
# Provides: object-drive-1.0
# Description: object-drive-1.0 server process
### END INIT INFO

import sys, os, subprocess, re, time, signal
from pwd import getpwnam
from grp import getgrnam

# init scripts must write a validly-named lockfile
username = "object-drive"
groupname = "services"
service = "object-drive-1.0"
lockfile = os.path.join('/var/lock/subsys', service)
pidfile = "/opt/services/object-drive-1.0/pidfile"
static_root = "/opt/services/object-drive-1.0/libs/server/static"
templates = os.path.join(static_root, "templates")
# Default logging location. Set OD_LOG_LOCATION in env.sh to override.
logfile = "/opt/services/object-drive-1.0/log/object-drive.log"
envfile = "/opt/services/object-drive-1.0/env.sh"
conf = "/opt/services/object-drive-1.0/object-drive.yml"
default_ciphers = "--addCipher TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 --addCipher TLS_RSA_WITH_AES_128_CBC_SHA"


def change_owner(path, uid, gid, perms):
    """
    Set permissions on file or dir. uid and perms must be int type, eg. 0o755.
    Group is ignored with -1.
    """
    os.chown(path, uid, gid)
    os.chmod(path, perms)


def create_dir_not_exists(path):
    if not os.path.exists(path):
        print 'creating %s' % path
        os.makedirs(path)


def get_ciphers():
    if os.getenv("OD_CIPHERS"):
        return os.getenv("OD_CIPHERS")
    return default_ciphers


def lock():
    open(lockfile, 'w').close()


def locked():
    return os.path.exists(lockfile)


def touch_file(path):
    if not os.path.exists(path):
        f = open(path, "w")
        f.close()


def unlock():
    os.remove(lockfile)


def start():
    # Source our shell environment from env.sh file.
    shell_source(envfile)
    # Declaring global required for mutation.
    global logfile
    if not os.getenv("OD_CACHE_ROOT"):
        os.environ["OD_CACHE_ROOT"] = "/opt/services/object-drive-1.0/cache"
    if os.getenv("OD_LOG_LOCATION"):
        location = os.getenv("OD_LOG_LOCATION")
        print "Using log location set by $OD_LOG_LOCATION: " + location
        logfile = location
    if os.path.exists(pidfile):
        os.remove(pidfile)
    if not is_absolute_path(logfile):
        print "Logging location must be absolute path"
        os.exit(1)

    # Get uid of user account.
    uid = getpwnam(username).pw_uid
    # Get gid of group account.
    gid = getgrnam(groupname).gr_gid

    # Capture root's environment in dictionary. Pass to Popen.
    env_for_proc = dict()
    for k in os.environ.keys():
        env_for_proc[k] = os.getenv(k, "")

    # Change permissions on configuration file.
    os.chown(conf, uid, -1)

    # Change ownership of logging directory and file, if the file exists.
    logging_dir = os.path.split(logfile)[0]
    create_dir_not_exists(logging_dir)
    change_owner(logging_dir, uid, gid, 0o750)
    if os.path.exists(logfile):
        change_owner(logfile, uid, gid, 0o750)

    # Change ownership of cache dir and its contents.
    cache_dir = os.path.split(os.getenv("OD_CACHE_ROOT"))[0]
    create_dir_not_exists(cache_dir)
    os.chown(cache_dir, uid, -1)
    for root, dirs, files in os.walk(cache_dir):
        for d in dirs:
            change_owner(os.path.join(root, d), uid, gid, 0o750)
            for n in files:
                change_owner(os.path.join(root, n), uid, gid, 0o750)
    
    # Change ownership of certificates if exists, and beneath the base path
    if os.getenv("OD_CERTPATH"):
        certpath = os.getenv("OD_CERTPATH")
        if os.path.exists(certpath):
            if os.getenv("OD_BASEPATH"):
                basepath = os.getenv("OD_BASEPATH")
                if os.path.exists(basepath):
                    if certpath.startswith(basepath):
                        for root, dirs, files in os.walk(certpath):
                            for d in dirs:
                                change_owner(os.path.join(root, d), uid, gid, 0o750)
                                for n in files:
                                    change_owner(os.path.join(root, n), uid, gid, 0o750)

    # Change ownership of pidfile. 
    touch_file(pidfile)
    change_owner(pidfile, uid, gid, 0o750)

    # Change the user for the currently executing script, e.g. "su down". 
    os.setuid(uid)
    #os.setgid(gid)

    print "Starting object-drive-1.0"
    f = open(logfile, "a")

    ciphs = get_ciphers()
    splitted = ciphs.split(" ")
    command = ['/opt/services/object-drive-1.0/object-drive-1.0', '--conf', conf, '--templateDir', templates, "--staticRoot", static_root]
    command.extend(splitted)
    ps = subprocess.Popen(command, stdout=f, stderr=f, env=env_for_proc)
    with open(pidfile, "w") as pf:
        pf.write(str(ps.pid) + '\n')


def stop():
    print "Stopping object-drive-1.0"
    if not os.path.exists(pidfile):
        print "error: could not find pidfile at %s. object-drive-1.0 may be running under a custom script"
        sys.exit(1)
    try:
        pid = get_pid_from_pidfile(pidfile)
        # Remove invalid pidfile.
        if not is_process_running(pid):
            print "removing stale pidfile"
            os.remove(pidfile)
            sys.exit(1)
        os.kill(int(pid), signal.SIGTERM)
        print "SIGTERM sent to process. If there are files pending upload, it may take time for the process to clean up files and exit."
        # Sleep for same time paired to signals.go for accepting/finishing new work
        time.sleep(5)
    except Exception as e:
        print e
        print "could not kill pid %s" % pid
        sys.exit(1)
    os.remove(pidfile)

def restart():
    stop()
    lock()
    start()


def status():
    if not locked():
        print "STATUS: object-drive-1.0 not running"
        return 3
    else:
        if not os.path.exists(pidfile):
            print "STATUS: object-drive-1.0 is not running"
            return 0
        pid = get_pid_from_pidfile(pidfile)
        if not is_process_running(pid):
            print "pidfile exists but object-drive-1.0 not running"
            print "removing stale pidfile"
            os.remove(pidfile)
            return 1
        print "STATUS: object-drive-1.0 is running"
        return 0


def get_pid_from_pidfile(path):
    with open(path, 'r') as f:
        pid = f.readline().split('\n')[0]
        if len(pid) > 0:
            return pid
        else:
            raise ValueError("invalid pid read from file: %s" % pid)


def is_process_running(process_id):
    try:
        os.kill(int(process_id), 0)
        return True
    except OSError:
        return False


def is_absolute_path(path):
    return os.path.isabs(path)


def shell_source(script):
    """
    Emulate the behavior of `source foo.sh`
    """
    pipe = subprocess.Popen(". %s; env" % script, stdout=subprocess.PIPE, shell=True)
    output = pipe.communicate()[0]
    env = dict((line.split("=", 1) for line in output.splitlines()))
    os.environ.update(env)


# Script entry point.
if __name__ == '__main__':
    try:
        if len(sys.argv) == 1:
            raise ValueError
        create_dir_not_exists(os.path.split(logfile)[0])
        command = str(sys.argv[1]).strip().lower()
        if command == 'start':
            lock()
            start()
            sys.exit(0)
        elif command == 'stop':
            stop()
            unlock()
            sys.exit(0)
        elif command == 'restart' or command == 'force-reload':
            restart()
            sys.exit(0)
        elif command == 'status':
            ok = status()
            sys.exit(ok)
        else:
            raise ValueError
    except (SystemExit):
        pass
    except (ValueError):
        print >> sys.stderr, "Usage: %s [start|stop|restart|status]" % service
        sys.exit(2)
    except:
        # Other errors
        extype, value = sys.exc_info()[:2]
        print >> sys.stderr, "ERROR: %s (%s)" % (extype, value)
        sys.exit(1)


